На основе предоставленных данных можно сделать несколько выводов и рассмотреть подходы к предсказанию поломок.

---

### 1. Анализ данных

#### Общая информация

- Данные содержат информацию о поломках блока розлива за период с 2020 по 2024 год.
- Каждая запись включает
  - Время начала и конца простоя.
  - Тип поломки (Reason 3 ID = 2010004, Breakdowns) - примем всё за один класс - поломки.
  - Описание проблемы.
  - Продолжительность простоя.

#### Основные типы проблем

- Замена дросселей, тормозных пластин, прижимных колпаков, сбросных дросселей.
- Устранение недоливов.
- Сбои в работе датчиков и программного обеспечения.
- Механические повреждения (например, заклинивание цепей или рычагов).

Обработав текст причин поломок, провели кластеризацию по длительности поломок. Результат от самого большего к меньшему представлен на диаграмме ниже

![1740326096202](images/Readme/1740326096202.png)

Резульат клатсеризации и группировки по средней и суммарной длительности поломок

![1740418907519](images/Readme/1740418907519.png)

> Кластер    Длительность  
> 0               5.602675  
>
> 1               3.181621  
>
> 2               10.234375

Визуализация кластеров наглядно в зависимости от

#### Статистика

- Общий итог времени простоя 3,253 минуты.
- Частота замены компонентов указывает на их износ и необходимость профилактического обслуживания.

#### Анализ частоты поломок

Анализ частоты поломок проводился по количеству поломок в каждом классе

```python
# Подсчет частоты поломок для каждого типа элемента
frequency_by_element = data['Элемент'].value_counts()

# Топ-10 наиболее часто встречающихся причин поломок
top_10_elements = frequency_by_element.head(10)

```

* Вывели топ 10 самых часто встречающихся поломок. Отобразили на диаграмме

![1740395030890](images/Readme/1740395030890.png)

* Так же на круговой диаграмме, в % от общего числа поломок

![1740395061785](images/Readme/1740395061785.png)

---

### 3. Преобразование данных

Чтобы эффективно использовать эти данные для анализа или моделирования, необходимо их структурировать и подготовить

#### Шаг 1 Преобразование времени

- Конвертируем столбцы Начало простоя и Конец простоя в формат datetime.

  ```Python
  # Приведём время начала поломки в datetime
  kv = {
      'сен':'09',
      'окт':'10',
      'ноя':'11',
      'дек':'12',
      'янв':'01',
      'фев':'02',
      'мар':'03',
      'апр':'04',
      'май':'05',
      'июн':'06',
      'июл':'07',
      'авг':'08',
  }

  def replace_month(date_str):
      for month_abbr, month_num in kv.items():
          date_str = date_str.replace(month_abbr, month_num)
      return date_str


  data['Начало простоя'] = data['Начало простоя'].apply(replace_month)
  data['Конец простоя'] = data['Конец простоя'].apply(replace_month)


  data['Начало простоя'] = pd.to_datetime(data['Начало простоя'], format='%d-%m-%y %H:%M:%S')
  data['Конец простоя'] = pd.to_datetime(data['Конец простоя'], format='%d-%m-%y %H:%M:%S')
  ```

#### Шаг 2 Разделение описания

- Разбили столбец Описание на отдельные поля

  ```Python
  pattern = r'(?:Замена|устранение|не\s+работает|выбивает|залип|остановки|ремонт|заменена|замена|мех\.|кип)(.*?)(?:№|\b№№\b|#|:\s|на\s|по\s)(\d+(?:,\s*\d+)*)'

  # Функция для парсинга строки
  def parse_description(description):
  	try:
  		match = re.search(pattern, description, re.IGNORECASE)
  		if match:
  			element = match.group(1).strip()
  			numbers = match.group(2).replace('№', '').replace('#', '').strip() 
  			return element.lower(), numbers
  		return None, None
  	except TypeError:
  		return None, None

  data[["Элемент", "Номер"]] = data["Описание"].apply(lambda x: pd.Series(parse_description(x)))

  # Разделяем номера, если их несколько
  data = data.dropna(subset=["Номер"])  # Удаляем строки без найденных номеров
  # data["Номер"] = data["Номер"].str.split(',').explode().str.strip()

  # Выводим результат
  print(data[["Элемент", "Номер"]])

  # Сохраняем в CSV файл (если нужно)
  data[["Элемент", "Номер"]].to_csv("parsed_data.csv", index=False, encoding="utf-8")
  ```

  > Элемент                                        Номер
  > 0    двух дросселей на наполнителе    17
  > 1        первого ролика на столике        1
  > 2         нагнетательного дросселя         89
  > 3         нагнетательного дросселя         105
  > 4               тормозной пластины            76
  > ..                               ...                               ...
  > 504                       недолива                     71
  > 517                  тор. пластины                   63
  > 518                       дросселя                      33
  > 526             тормозной пластины            10  
  > 527             тормозной пластины             66  
  >

#### Шаг 3 Преобразование слов в леммы (Лемматизация)

- Означает привести слова к начальной форме, для уменьшьения количества классов из за различных форм слов в Описании

  ```Python
  morph = pymorphy2.MorphAnalyzer()


  def lemmatize_text(text):
      if not isinstance(text, str):  
          return ''
      words = text.split()  # Разделяем текст на слова
      lemmas = [morph.parse(word)[0].normal_form for word in words]  
      return ' '.join(lemmas)  

  data['Элемент'] = data['Элемент'].apply(lemmatize_text)
  ```

#### Шаг 4 Создание временных меток

- Добавили признаки дополнительные признаки

  - Месяц и день недели, когда произошла поломка.
  - Время суток (утро, день, вечер, ночь).
  - Интервал времени между последней заменой компонента и текущей поломкой.

  ```Python

  data['Начало простоя (часы)'] = data['Начало простоя'].apply(lambda x: x.split(' ')[1])
  data['Начало простоя (часы)'] = pd.to_datetime(data['Начало простоя (часы)'])

  def get_time_of_day(time):
      hour = time.hour
      if 6 <= hour < 12:
          return 'Утро'
      elif 12 <= hour < 18:
          return 'День'
      elif 18 <= hour < 24:
          return 'Вечер'
      else:
          return 'Ночь'


  data['Время суток'] = data['Начало простоя (часы)'].apply(lambda x: get_time_of_day(x))
  ```

#### Шаг 5 Подготовка для прогнозирования

- Создадим временной ряд, где каждая строка соответствует определенному моменту времени (например, день или месяц), а целевая переменная — количество поломок или общее время простоя.
- Так как в нашем случае приведены данные только для поломок, то для обучения модели нужно добавить шум в данные - путь этим шумом будет заполнение пропусков между поломками на нормальныый режим работы

```python
# сгенерируем данные

from datetime import timedelta

normal_periods = []

for i in range(len(data) - 1):
    end_of_breakdown = data.loc[i, 'Конец простоя']
    start_of_next_breakdown = data.loc[i + 1, 'Начало простоя']
  
    # Если между поломками есть разрыв, создаем нормальные периоды
    if start_of_next_breakdown > end_of_breakdown:
        current_time = end_of_breakdown
        step = timedelta(minutes=30)  # Шаг для создания нормальных периодов (например, 30 минут)
    
        while current_time + step <= start_of_next_breakdown:
            normal_start = current_time
            normal_end = current_time + step
            normal_periods.append((normal_start, normal_end))
            current_time += step

normal_df = pd.DataFrame(normal_periods, columns=['Начало простоя', 'Конец простоя'])

normal_df['Метка'] = 'Нормальный'

data['Метка'] = 'Поломка'

combined_df = pd.concat([data[['Начало простоя', 'Конец простоя', 'Метка']], normal_df], ignore_index=True)
```

#### Шаг 6: Балансировка данных

* Число классов "Поломка" и "Норма" слишкорм разное - нормальных меток больше, чем сломанных. Проведём балансировку классов

  ```python
  # проведём балансировку

  from sklearn.utils import resample

  # Разделяем данные на классы
  breakdown_data = combined_df[combined_df['Метка'] == 'Поломка']
  normal_data = combined_df[combined_df['Метка'] == 'Нормальный']


  normal_downsampled = resample(
      normal_data,
      replace=False, 
      n_samples=len(breakdown_data),  
      random_state=42
  )

  balanced_df = pd.concat([breakdown_data, normal_downsampled], ignore_index=True)


  balanced_df = balanced_df.sample(frac=1, random_state=42).reset_index(drop=True)

  print(balanced_df.head())
  ```
* Так как данные стабильны - "зашумим" их

  ```Py

  def add_noise_to_timestamps(timestamps, noise_level=5):
      """
      Добавляет случайный шум к временным меткам.
      :param timestamps: Pandas Series с временными метками.
      :param noise_level: Максимальное отклонение в минутах.
      :return: Pandas Series с измененными временными метками.
      """
      return timestamps + pd.to_timedelta(np.random.uniform(-noise_level, noise_level, size=len(timestamps)), unit='m')

  # Применяем функцию к нормальным периодам
  balanced_df.loc[balanced_df['Метка'] == 'Нормальный', 'Начало простоя'] = \
      add_noise_to_timestamps(balanced_df.loc[balanced_df['Метка'] == 'Нормальный', 'Начало простоя'])

  balanced_df.loc[balanced_df['Метка'] == 'Нормальный', 'Конец простоя'] = \
      add_noise_to_timestamps(balanced_df.loc[balanced_df['Метка'] == 'Нормальный', 'Конец простоя'])

  ```

---

### 2. Алгоритм предсказания поломок

#### Подход 1 Регрессия для прогнозирования времени простоя

- Целевая переменная время простоя.
- Признаки
  - Прошлое время простоя.
  - Частота поломок для данного компонента.
  - Месяцвремя суток.

#### Подход 2 Классификация для предсказания вероятности поломки

- Целевая переменная вероятность поломки (данет).
- Признаки
  - Время с момента последней замены компонента.
  - Тип компонента.
  - Нагрузка на оборудование (если доступна).

#### Подход 3 Анализ MTBF

- Вычислите среднее время между поломками для каждого компонента.
- На основе этого планируйте профилактическое обслуживание.

---

### 5. Пример кода для преобразования данных (Python)

```python
import pandas as pd

# Загрузка данных
df = pd.read_excel('Поломки_Блок Розлива_2020-2024v2.xlsx')

# Преобразование времени
df['Начало простоя'] = pd.to_datetime(df['Начало простоя'], format='%d-%b-%y %H%M%S')
df['Конец простоя'] = pd.to_datetime(df['Конец простоя'], format='%d-%b-%y %H%M%S')

# Вычисление продолжительности простоя
df['Продолжительность'] = (df['Конец простоя'] - df['Начало простоя']).dt.total_seconds()  3600

# Разбиение описания на составляющие
df['Наполнитель'] = df['Описание'].str.extract(r'(d+)')
df['Компонент'] = df['Описание'].str.extract(r'(дроссельтормозной пластиныколоколприжимной стакан)')
df['Причина'] = df['Описание'].str.extract(r'(заменаустранение недоливовпустые банкизаклинивание)')

# Группировка по компонентам
component_summary = df.groupby('Компонент').agg({'Продолжительность' 'sum', 'Описание' 'count'}).reset_index()
component_summary.columns = ['Компонент', 'Общее время простоя (ч)', 'Количество поломок']

# Группировка по наполнителям
filler_summary = df.groupby('Наполнитель').agg({'Продолжительность' 'sum', 'Описание' 'count'}).reset_index()
filler_summary.columns = ['Наполнитель', 'Общее время простоя (ч)', 'Количество поломок']

# Сохранение результатов
component_summary.to_csv('component_summary.csv', index=False)
filler_summary.to_csv('filler_summary.csv', index=False)

print(component_summary.head())
print(filler_summary.head())
```

---

### 6. Рекомендации

- Для профилактики Регулярно проверяйте компоненты с высоким MTBF и планируйте их замену заранее.
- Для анализа Визуализируйте данные (графики поломок по времени, тепловые карты для разных компонентов).
- Для прогнозирования Используйте исторические данные для обучения модели и тестирования её на новых данных.

Если нужна помощь с конкретным этапом, напишите!

Для расчета остаточного ресурса оборудования блока розлива необходимо учитывать несколько факторов, которые зависят от данных из предоставленной таблицы. Остаточный ресурс — это время, которое оборудование может работать до достижения предельного состояния (конца срока службы). Вот пошаговый план для расчета:

---

### **1. Извлечь ключевые параметры из таблицы:**

#### **Основные данные:**

- **Моточасы наработки:** 151,126 моточасов.
- **Рекомендованный срок службы от производителя:** 15 лет.
- **Год выпуска оборудования:** 2002 год.
- **Среднегодовые моточасы работы:** 4,527 часов.

#### **Текущая дата:**

- Таблица содержит данные по состоянию на июль 2024 года.
- Возраст оборудования: $ 2024 - 2002 = 22 $ года.

---

### **2. Расчет общего количества моточасов за весь период эксплуатации:**

Используем формулу:

$$
\text{Общие моточасы} = \text{Моточасы наработки} + (\text{Среднегодовые моточасы} \times \text{Количество полных лет после последнего известного значения})
$$

Последнее известное значение моточасов — 151,126 моточасов (по состоянию на конец 2023 года).

- За 2024 год (до июля): $ \text{Время активной работы Блока розлива} = 5,114 $ часов.
- Общее количество моточасов на 30 июня 2024 года:

$$
151,126 + 5,114 = 156,240 \, \text{моточасов}.
$$

---

### **3. Определить максимальный ресурс оборудования:**

Производитель указывает рекомендованный срок службы в 15 лет. Для расчета максимального ресурса в моточасах используем среднегодовое значение моточасов:

$$
\text{Максимальный ресурс} = \text{Среднегодовые моточасы} \times \text{Срок службы}
$$

$$
\text{Максимальный ресурс} = 4,527 \, \text{ч/год} \times 15 \, \text{лет} = 67,905 \, \text{моточасов}.
$$

Однако, если оборудование уже работает 22 года, то его фактический ресурс может быть выше или ниже рекомендованного значения. Это зависит от условий эксплуатации, обслуживания и частоты поломок.

---

### **4. Корректировка ресурса на основе текущих данных:**

#### **Анализ MTBF (среднее время между поломками):**

- MTBF показывает, как часто оборудование выходит из строя.
- В последние годы MTBF увеличился:
  - 2023 год: 46 часов.
  - 2024 год: 176 часов.

Это может свидетельствовать о том, что оборудование находится в стабильном состоянии и требует меньшего внимания к ремонту. Однако, возраст оборудования все равно влияет на его надежность.

#### **Превышение рекомендованного срока службы:**

- Устройство проработало на 7 лет больше рекомендованного срока (22 года вместо 15).
- Возможно, производительность снижена или оборудование проходит усиленное техобслуживание.

---

### **5. Расчет остаточного ресурса:**

#### **Метод 1: На основе времени работы**

- Если предположить, что оборудование продолжит работать со средней нагрузкой (4,527 моточасов в год), то:

$$
\text{Остаточный ресурс} = \frac{\text{Максимальный ресурс} - \text{Текущие моточасы}}{\text{Среднегодовые моточасы}}
$$

$$
\text{Остаточный ресурс} = \frac{67,905 - 156,240}{4,527} = -19.48 \, \text{лет}.
$$

Этот результат отрицательный, что указывает на то, что оборудование уже давно вышло за рамки рекомендованного срока службы. Это нормально для старых машин, если они поддерживаются в рабочем состоянии.

#### **Метод 2: На основе MTBF**

- MTBF в 2024 году составляет 176 часов. Это значит, что оборудование может работать без поломок в течение этого времени.
- Оценка остаточного ресурса на основе MTBF:

$$
\text{Остаточные часы работы} = \text{MTBF} \times \text{Коэффициент надежности}.
$$

Если коэффициент надежности принять равным 0.8 (80% от MTBF), то:

$$
\text{Остаточные часы работы} = 176 \times 0.8 = 140.8 \, \text{часов}.
$$

#### **Метод 3: На основе текущей производительности**

- Средняя производительность за 2024 год (за первые 7 месяцев): $ \frac{5,114}{7} = 730.6 \, \text{ч/месяц} $.
- Остаточное время работы equipmenta при таком режиме:

$$
\text{Остаточные месяцы работы} = \frac{\text{Максимальный ресурс} - \text{Текущие моточасы}}{\text{Среднемесячная нагрузка}}.
$$

$$
\text{Остаточные месяцы работы} = \frac{67,905 - 156,240}{730.6} = -121.0 \, \text{месяцев}.
$$

Это также указывает на то, что оборудование уже давно вышло за рамки своего срока службы.

---

### **6. Практические выводы:**

#### **Фактический остаточный ресурс:**

- Оборудование уже значительно превысило рекомендованный срок службы.
- На основе MTBF можно предположить, что оборудование сможет работать еще примерно **140.8 часов** без поломок, но это не гарантирует долгосрочную работоспособность.

#### **Рекомендации:**

1. **Усилить профилактическое обслуживание:** Регулярно проверять компоненты с высокой частотой замены (например, дроссели, тормозные пластины).
2. **Рассмотреть модернизацию или замену оборудования:** Поскольку оборудование проработало почти в 1.5 раза дольше рекомендованного срока, вероятность серьезных поломок возрастает.
3. **Мониторинг нагрузки:** Если нагрузка на оборудование остается высокой, возможен более быстрый износ.

---

### **7. Пример кода для автоматического расчета (Python):**

```python
# Данные
max_resource_years = 15  # Максимальный срок службы в годах
avg_annual_hours = 4527  # Среднегодовые моточасы
current_hours = 156240  # Текущие моточасы (на 30 июня 2024)
mtbf_2024 = 176  # MTBF в 2024 году

# Максимальный ресурс в моточасах
max_resource_hours = max_resource_years * avg_annual_hours

# Остаточный ресурс в часах (на основе MTBF)
remaining_hours_based_on_mtbf = mtbf_2024 * 0.8  # 80% от MTBF

# Остаточный ресурс в годах (на основе моточасов)
remaining_years_based_on_hours = (max_resource_hours - current_hours) / avg_annual_hours

# Вывод результатов
print(f"Максимальный ресурс оборудования: {max_resource_hours:.0f} моточасов.")
print(f"Текущие моточасы: {current_hours:.0f} моточасов.")
print(f"Остаточный ресурс на основе MTBF: {remaining_hours_based_on_mtbf:.1f} часов.")
print(f"Остаточный ресурс на основе моточасов: {remaining_years_based_on_hours:.1f} лет.")
```

---

### **8. Итог:**

На основе анализа:

- Фактический остаточный ресурс оборудования составляет **около 140.8 часов** без учета серьезных поломок.
- Оборудование уже давно вышло за рамки рекомендованного срока службы и требует усиленного контроля или замены.
